// NOTE: This passage is easier to read in NotePad
// because certain lines are extremely long

// JsonObject that lists all rules
// it is required that all function look like
// function name(){...}
// if there are comments that belong to the function
// please locate them inside of the function

// beware, the validate part of the rule can be tricky
// when entering it into this list
// I have created a StringFlattener class for this purpose
// look at StringFlattener.java for details on what is required
// for the rules processor to be able to successfully process
// a validation string

// there is a problem with processing the print statement
// that contains quoted strings (e.g. print("\"a\":\"b\"))
// because there are already backslashes in these statements
// and i would have to differentiate these backslashed quotes
// from quotes that were not before but are now backslashed
// to be entered in as a validation

RuleList = {Rules:[
	{
	rule_id:"table_1",
	wcag_code:"1.3.1",
	sect508_code:"22.a",
	param:tags,
	validate:
		function (tags)
		{
			// function definition that checks a table for summary
			function tablerulecheckSummaryexists(table)
			{
				var contains = false;
				var pass_fail = new Object();
				for(item in table)
				{
					if(item.toLowerCase() == "summary")
					{
						contains = true;
					}
				}
				if(!contains)
				{
					pass_fail.passed = "false";
					pass_fail.message = "this table does not contain the summary attribute";
				}
				else
				{
					pass_fail.passed = "true";
					pass_fail.message = "this table does contain the summary attribute, please make sure the summary is an accurate description of the table";
				}
				return pass_fail;
			}
	
			// function definition that traverses the tags
			function tableruletraversal(tags)
			{
				// checks to see that tables have a summary attribute
				// standard traversal (either an array or object list or string)
				if(tags.constructor == Array)
				{
					for(var i=0;i<tags.length;i++)
					{
						tableruletraversal(tags[i]);
					}
				}
				// base case
				else if(tags.constructor == String)
				{
				}
				else
				{
					for(item in tags)
					{
						var val = tags[item];
						if(item.toLowerCase() == "table")
						{
							// Since json compresses xml,
							// multiple tables in one document,
							// may be compressed into an array
							if(val.constructor == Array)
							{
								for(var k=0;k<val.length;k++)
									result.test_results.push(tablerulecheckSummaryexists(val[k]));
							}
							else
								result.test_results.push(tablerulecheckSummaryexists(val));
						}
						else
							tableruletraversal(val);
					}
				}
			}

			// variable local to function to store all the results
			var result = new Object();
			result.rule_id = "table_1";
			result.wcag_code = "1.3.1";
			result.sect508_code = "22.a";
			result.test_results = new Array();

			// function call to begin rule validation
			tableruletraversal(tags);

			return result;
		},
	pass_message:"this table contains the summary attribute, please make sure the summary is an accurate description of the table",
	fail_message:"this table does not contain the summary attribute",
	title:"Data tables must use summary attribute."
	},
	{
	rule_id:"table_2",
	wcag_code:"1.3.1",
	sect508_code:"22.g",
	param:tags,
	validate:
		function (tags)
		{
			// checks if the th tag exists
			function tablerulecheckTHexists(table)
			{
				var pass_fail = new Object();
				var contains = false;
				for(item in table)
				{
					if(item.toLowerCase() == "th")
						contains = true;
				}

				if(!contains)
				{
					pass_fail.passed = "false";
					pass_fail.message = "this table's first row does not consist of th tags";
				}
				else
				{
					pass_fail.passed = "true";
					pass_fail.message = "this table does contain th tags, make sure that the first row accurately describes the columns below";
				}
				return pass_fail;
			}
	
			// function definition that traverses the tags
			function tableruletraversal(tags)
			{
				// checks to see that tables have th tags
				// standard traversal (either an array or object list or string)
				if(tags.constructor == Array)
				{
					for(var i=0;i<tags.length;i++)
					{
						tableruletraversal(tags[i]);
					}
				}
				// base case
				else if(tags.constructor == String)
				{
				}
				else
				{
					for(item in tags)
					{
						var val = tags[item];
						if(item.toLowerCase() == "table")
						{
							// Since json compresses xml,
							// multiple tables in one document,
							// may be compressed into an array
							if(val.constructor == Array)
							{
								for(var k=0;k<val.length;k++)
									result.test_results.push(tablerulecheckTHexists(val[k]));
							}
							else
								result.test_results.push(tablerulecheckTHexists(val));
						}
						else
							tableruletraversal(val);
					}
				}
			}

			// variable local to function to store all the results
			var result = new Object();
			result.rule_id = "table_2";
			result.wcag_code = "1.3.1";
			result.sect508_code = "22.g";
			result.test_results = new Array();

			// function call to begin rule validation
			tableruletraversal(tags);

			return result;
		},
	pass_message:"this table does contain th tags, make sure that the first row accurately describes the columns below",
	fail_message:"this table's first row does not consist of th tags",
	title:"Data tables must use th elements"
	},
	{
	rule_id:"table_3",
	wcag_code:"1.3.1",
	sect508_code:"22.a",
	param:tags,
	validate:
		function (tags)
		{
			// checks if the th tag exists
			function tablerulecheckSummaryAttributeNonEmpty(table)
			{
				var pass_fail = new Object();
				var nonEmpty = false;
				for(item in table)
				{
					
					if(item.toLowerCase() == "summary")
					{
						var val = table[item];
						if(val != null && val.length > 0)
							nonEmpty = true;
					}
				}

				if(!nonEmpty)
				{
					pass_fail.passed = "false";
					pass_fail.message = "a summary attribute is empty";
				}
				else
				{
					pass_fail.passed = "true";
					pass_fail.message = "summary attributes are non empty, please check to make sure that the description accurately describes the table";
				}
				return pass_fail;
			}
	
			// function definition that traverses the tags
			function tableruletraversal(tags)
			{
				// checks to see that tables have th tags
				// standard traversal (either an array or object list or string)
				if(tags.constructor == Array)
				{
					for(var i=0;i<tags.length;i++)
					{
						tableruletraversal(tags[i]);
					}
				}
				// base case
				else if(tags.constructor == String)
				{
				}
				else
				{
					for(item in tags)
					{
						var val = tags[item];
						if(item.toLowerCase() == "table")
						{
							// Since json compresses xml,
							// multiple tables in one document,
							// may be compressed into an array
							if(val.constructor == Array)
							{
								for(var k=0;k<val.length;k++)
									result.test_results.push(tablerulecheckSummaryAttributeNonEmpty(val[k]));
							}
							else
								result.test_results.push(tablerulecheckSummaryAttributeNonEmpty(val));
						}
						else
							tableruletraversal(val);
					}
				}
			}

			// variable local to function to store all the results
			var result = new Object();
			result.rule_id = "table_3";
			result.wcag_code = "1.3.1";
			result.sect508_code = "22.a";
			result.test_results = new Array();

			// function call to begin rule validation
			tableruletraversal(tags);

			return result;
		},
	pass_message:"summary attributes are non empty, please check to make sure that the description accurately describes the table",
	fail_message:"a summary attribute is empty",
	title:"Summary attribute content must be unique."
	},
	{
	rule_id:"table_4",
	wcag_code:"1.3.2",
	sect508_code:"22.h",
	param:tags,
	validate:
		function (tags)
		{
			// checks if tables contain nested tables
			function tablerulecheckForNestedTable(tableOrInside)
			{
				// traverse the table and look for another table
				// standard traversal (either an array or object list or string)
				if(tableOrInside.constructor == Array)
				{
					for(var i=0;i<tableOrInside.length;i++)
					{
						tableSeen = tableSeen || tablerulecheckForNestedTable(tableOrInside[i]);
					}
					return tableSeen;
				}
				// base case
				else if(tableOrInside.constructor == String)
				{
					return false;
				}
				else
				{
					var tableSeen = false;
					for(item in tableOrInside)
					{
						var val = tableOrInside[item];
						if(item.toLowerCase() == "table")
						{
							return true;
						}
						else
						{
							tableSeen = tableSeen || tablerulecheckForNestedTable(val);
						}
					}
					return tableSeen;
				}
			}
	
			// function definition that traverses the tags
			function tableruletraversal(tags)
			{
				// standard traversal (either an array or object list or string)
				if(tags.constructor == Array)
				{
					for(var i=0;i<tags.length;i++)
					{
						tableruletraversal(tags[i]);
					}
				}
				// base case
				else if(tags.constructor == String)
				{
				}
				else
				{
					for(item in tags)
					{
						var val = tags[item];
						if(item.toLowerCase() == "table")
						{
							// Since json compresses xml,
							// multiple tables in one document,
							// may be compressed into an array
							if(val.constructor == Array)
							{
								for(var k=0;k<val.length;k++)
								{
									var tableSeen = false;
									tableSeen = tablerulecheckForNestedTable(val[k]);

									var pass_fail = new Object();

									if(tableSeen)
									{
										pass_fail.passed = "false";
										pass_fail.message = "a table does contain nested tables, please do not use nested tables for positioning";
									}
									else
									{
										pass_fail.passed = "true";
										pass_fail.message = "tables do not contain nested tables";
									}
									result.test_results.push(pass_fail);
								}
							}
							else
							{
								var tableSeen = false;
								tableSeen = tablerulecheckForNestedTable(val);

								var pass_fail = new Object();

								if(tableSeen)
								{
									pass_fail.passed = "false";
									pass_fail.message = "a table does contain nested tables, please do not use nested tables for positioning";
								}
								else
								{
									pass_fail.passed = "true";
									pass_fail.message = "tables do not contain nested tables";
								}
								result.test_results.push(pass_fail);
							}
						}
						else
							tableruletraversal(val);
					}
				}
			}

			// variable local to function to store all the results
			var result = new Object();
			result.rule_id = "table_4";
			result.wcag_code = "1.3.2";
			result.sect508_code = "22.h";
			result.test_results = new Array();

			// function call to begin rule validation
			tableruletraversal(tags);

			return result;
		},
	pass_message:"tables do not contain nested tables",
	fail_message:"a table does contain nested tables, please do not use nested tables for positioning",
	title:"Do not use nested tables for positioning."
	},
	{
	rule_id:"title_1",
	wcag_code:"2.4.2",
	sect508_code:"22.i",
	param:title,
	validate:
		function (title)
		{
			// checks to see that the title element is not empty
			function titleRuleCheckNonEmpty(title)
			{
				var pass_fail = new Object();
				if(title == null || title == "")
				{
					pass_fail.passed = "false";
					pass_fail.message = "title element is empty";
				}
				else
				{
					pass_fail.passed = "true";
					pass_fail.message = "title element is not empty, make sure it accurately describes the document";
				}

				return pass_fail;
			}

			// variable local to function to store all the results
			var result = new Object();
			result.rule_id = "title_1";
			result.wcag_code = "2.4.2";
			result.sect508_code = "22.i";
			result.test_results = new Array();

			// function call to begin rule validation
			result.test_results.push(titleRuleCheckNonEmpty(title));

			return result;
		},
	pass_message:"title element is not empty, make sure it accurately describes the document",
	fail_message:"title element is empty",
	title:"Title element should not be empty."
	},
	{
	rule_id:"header_1",
	wcag_code:"2.4.2",
	sect508_code:"22.d",
	param:tags,
	validate:
		function (tags)
		{
			// checks to see that there are at most 2 h1 tags
			// and at least 1 h1 tag
			// all h1 tags must not be empty
			function h1TagRuleCheckOneOrTwoAndNotEmpty(tags)
			{
				var h1Nodes = getElementsByTagName(tags,"h1");
				var emptyH1Nodes = [];
				for(var i = 0; i < h1Nodes.length; i++)
				{
					var h1Node = h1Nodes[i];
					if(getNodeTextRecursively(h1Node).length == 0)
					{
						emptyH1Nodes.push(h1Node);
					} // end if
				} // end for

				var passed = (h1Nodes.length == 1 || h1Nodes.length == 2) && emptyH1Nodes.length == 0;

				var pass_fail = new Object();
				if(passed)
				{
					pass_fail.passed = "true";
					pass_fail.message = "there are 1 or 2 h1 tags that are not empty, however make sure content of h1 tags are descriptive headings";
				}
				else
				{
					pass_fail.passed = "false";
					pass_fail.message = "h1 tags do not exist or there are more than 2 h1 tags or there exist empty h1 tags";
				}

				return pass_fail;
			}

			// variable local to function to store all the results
			var result = new Object();
			result.rule_id = "header_1";
			result.wcag_code = "2.4.2";
			result.sect508_code = "22.d";
			result.test_results = new Array();

			// function call to begin rule validation
			result.test_results.push(h1TagRuleCheckOneOrTwoAndNotEmpty(tags));

			return result;
		},
	pass_message:"there are 1 or 2 h1 tags that are not empty, however make sure content of h1 tags are descriptive headings",
	fail_message:"h1 tags do not exist or there are more than 2 h1 tags or there exist empty h1 tags",
	title:"Missing or empty H1 element."
	},
	{
	rule_id:"author_1",
	wcag_code:"2.4.2",
	sect508_code:"22.i",
	param:author,
	validate:
		function (author)
		{
			// checks to see that the author element is not empty
			function authorRuleCheckNonEmpty(author)
			{
				var pass_fail = new Object();
				if(author == null || author == "")
				{
					pass_fail.passed = "false";
					pass_fail.message = "author element is empty";
				}
				else
				{
					pass_fail.passed = "true";
					pass_fail.message = "author element is not empty, make sure it accurately describes the author of the document";
				}

				return pass_fail;
			}

			// variable local to function to store all the results
			var result = new Object();
			result.rule_id = "author_1";
			result.wcag_code = "2.4.2";
			result.sect508_code = "22.i";
			result.test_results = new Array();

			// function call to begin rule validation
			result.test_results.push(authorRuleCheckNonEmpty(author));

			return result;
		},
	pass_message:"author element is not empty, make sure it accurately describes the author of the document",
	fail_message:"author element is empty",
	title:"Author element should not be empty."
	},
	{
	rule_id:"creator_1",
	wcag_code:"2.4.2",
	sect508_code:"22.i",
	param:creator,
	validate:
		function (creator)
		{
			// checks to see that the creator element is not empty
			function creatorRuleCheckNonEmpty(creator)
			{
				var pass_fail = new Object();
				if(creator == null || creator == "")
				{
					pass_fail.passed = "false";
					pass_fail.message = "creator element is empty";
				}
				else
				{
					pass_fail.passed = "true";
					pass_fail.message = "creator element is not empty, make sure it accurately describes the creator of the document";
				}

				return pass_fail;
			}

			// variable local to function to store all the results
			var result = new Object();
			result.rule_id = "creator_1";
			result.wcag_code = "2.4.2";
			result.sect508_code = "22.i";
			result.test_results = new Array();

			// function call to begin rule validation
			result.test_results.push(creatorRuleCheckNonEmpty(creator));

			return result;
		},
	pass_message:"creator element is not empty, make sure it accurately describes the creator of the document",
	fail_message:"creator element is empty",
	title:"Creator element should not be empty."
	}
]};

// all the code after this is required to call all validations
// in the rules list and then push the output onto a results
// list

// setup the results list
var resultsList = new Array();

// populate the results list
for(var i = 0; i < RuleList.Rules.length; i++)
{
	// call the rule and store in rule result
	var ruleResult = RuleList.Rules[i].validate(RuleList.Rules[i].param);
	resultsList.push(ruleResult);
}

// important pdf elements
// 	sections: sect
// 	headings: h1-h6
// 	paragraphs: p
// 	captions: caption
// 	tables: table
// 	figures/images: figure
// 	lists: L
// 	forms: form
// 	bookmarks: Bookmark

// initialize search array
var importantTags = new Array();
importantTags.push("sect");
importantTags.push("h1");
importantTags.push("h2");
importantTags.push("h3");
importantTags.push("h4");
importantTags.push("h5");
importantTags.push("h6");
importantTags.push("p");
importantTags.push("caption");
importantTags.push("table");
importantTags.push("figure");
importantTags.push("l");
importantTags.push("form");
importantTags.push("bookmark");

// initialize count array
var importantTagsCount = new Object();
importantTagsCount.sect = 0;
importantTagsCount.h1 = 0;
importantTagsCount.h2 = 0;
importantTagsCount.h3 = 0;
importantTagsCount.h4 = 0;
importantTagsCount.h5 = 0;
importantTagsCount.h6 = 0;
importantTagsCount.p = 0;
importantTagsCount.caption = 0;
importantTagsCount.table = 0;
importantTagsCount.figure = 0;
importantTagsCount.l = 0;
importantTagsCount.form = 0;
importantTagsCount.bookmark = 0;
importantTagsCountLength = 14;

countImportantTags(root);

// write results object to file
print("{\n");

// write results of tag counting to file (inside of results object)
print("	\"TagCount\":{\n");
for(item in importantTagsCount)
{
	print("		\"" + item + "\": \"" + importantTagsCount[item] + "\"");
	importantTagsCountLength--;
	if(importantTagsCountLength != 0)
		print(",\n");
	else
		print("\n");
}
print("	},\n");

// write results of rules to file (inside of results object)
print("	\"Results\":[\n");
for(var i = 0; i < resultsList.length; i++)
{
	print("		{\n");
	print("		\"rule_id\":\"" + resultsList[i].rule_id + "\",\n");
	print("		\"test_results\":[\n");

	var rule_results = resultsList[i].test_results;
	
	for(var j = 0; j < rule_results.length; j++)
	{
		print("			{\n");
		print("			\"passed\":\"" + rule_results[j].passed + "\",\n");
		print("			\"message\":\"" + rule_results[j].message + "\"\n");
		print("			}");
		if(j != rule_results.length - 1)
			print(",\n");
		else
			print("\n");
	}
	print("		],\n");
	print("		\"wcag_code\":\"" + resultsList[i].wcag_code + "\",\n");
	print("		\"sect508_code\":\"" + resultsList[i].sect508_code + "\"\n");
	print("		}");
	if(i != resultsList.length - 1)
		print(",\n");
	else
		print("\n");
}
print("	]\n");
print("}");